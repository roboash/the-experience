<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Eye Chase ‚Äî Platformer (Extended Level)</title>
  <style>
    :root{--bg:#071022;--ground:#0d2a3f;--player:#7afcff;--plat:#6ea8ff;--spike:#ff5b5b;--eye:#ff2a2a;--bounce:#7cff7a;--superbounce:#ff00ff}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#071022,#030717);color:#fff;display:flex;align-items:center;justify-content:center; text-shadow: 1px 1px 3px #000;}
    .wrap{width:min(1024px,96vw);padding:18px}
    .hud{display:flex;gap:12px;align-items:center;margin-bottom:8px}
    button{background:#1b2a44;color:#fff;border:1px solid #4f86ff;padding:8px 10px;border-radius:8px;cursor:pointer;text-shadow:1px 1px 2px #000;box-shadow:0 2px 5px rgba(0,0,0,0.5)}
    button:hover{background:#2a4065}
    button.active{background:#4f86ff;color:#fff;border:1px solid #fff}
    .muted{color:#e0e0e0;font-size:13px;text-shadow:1px 1px 2px #000}
    canvas{background:linear-gradient(180deg,#071228,#031021);display:block;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
    .overlay{position:absolute;left:0;right:0;text-align:center;color:#fff}

    /* Touch Controls */
    .touch-controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      display: none; /* Hidden by default, shown via JS if touch detected */
      justify-content: space-between;
      pointer-events: none; /* Let clicks pass through to canvas if needed */
    }
    .touch-btn {
      width: 80px;
      height: 80px;
      background: rgba(255, 255, 255, 0.15);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }
    .touch-btn:active { background: rgba(255, 255, 255, 0.3); }
    .d-pad { display: flex; gap: 15px; }

    /* Editor UI */
    #editorUI {
      display: none;
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: #1b2a44;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid #4f86ff;
      gap: 8px;
      flex-wrap: wrap;
      width: max-content;
      max-width: 90%;
      box-shadow: 0 10px 30px rgba(0,0,0,0.8);
      z-index: 100;
    }
    .tool-btn {
      width: 40px;
      height: 40px;
      border-radius: 6px;
      border: 1px solid #4f86ff;
      background: #0d1a2a;
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }
    .tool-btn:hover { background: #2a4065; }
    .tool-btn.active { background: #4f86ff; }
    .tool-sep { width: 1px; background: #4f86ff; margin: 0 4px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <button id="pauseBtn">‚è∏ Pause</button>
      <button id="restartBtn">Restart</button>
      <button id="muteBtn">üîä Music On</button>
      <button id="editBtn" onclick="toggleEditor()">‚úé Edit Level</button>
      <div class="muted">Move: A/D/Arrows ‚Ä¢ Jump: Space/W/Up</div>
      <div style="flex:1"></div>
      <div class="muted" style="color:#4f86ff;font-weight:bold">üíé <span id="diamondDisplay">0</span></div>
      <div class="muted" style="margin-left:12px">Coins: <span id="coins">0</span> ‚Ä¢ Best: <span id="bestCoins">0</span></div>
      <div style="margin-left:12px" class="muted">Distance Best: <span id="best">0</span></div>
    </div>
    <div style="position:relative">
      <canvas id="c" width="1024" height="576" tabindex="0" aria-label="Platformer eye chase"></canvas>
      <div id="msg" class="overlay" style="top:40%;font-size:28px;display:none">You Died ‚Äî Press Enter to restart</div>

      <!-- Pause Menu Overlay -->
      <div id="pauseMenu" class="overlay" style="top:35%;display:none;background:rgba(0,0,0,0.8);padding:40px;border-radius:20px;left:50%;transform:translateX(-50%);width:300px">
        <div style="font-size:32px;margin-bottom:20px;font-weight:bold">Paused</div>
        <button onclick="window.resumeGame()" style="display:block;width:100%;margin:10px 0;background:#4f86ff;font-size:20px;padding:10px">Resume</button>
        <button onclick="window.exitLevel()" style="display:block;width:100%;margin:10px 0;background:#ff5b5b;font-size:20px;padding:10px">Exit Level</button>
      </div>

      <!-- Editor UI Toolbar -->
      <div id="editorUI">
        <button class="tool-btn active" id="toolSelect" title="Select/Move (Del to remove)">‚úã</button>
        <div class="tool-sep"></div>
        <button class="tool-btn" id="toolGround" title="Add Ground">‚¨õ</button>
        <button class="tool-btn" id="toolPlat" title="Add Platform">‚ûñ</button>
        <button class="tool-btn" id="toolSpike" title="Add Spike">üî∫</button>
        <button class="tool-btn" id="toolCoin" title="Add Coin">üü°</button>
        <button class="tool-btn" id="toolBounce" title="Add Bounce Pad">üü©</button>
        <button class="tool-btn" id="toolSuper" title="Add Super Bounce">üü™</button>
        <button class="tool-btn" id="toolPortal" title="Set End Portal">üåÄ</button>
        <div class="tool-sep"></div>
        <button class="tool-btn" id="toolEraser" title="Eraser (Click to Delete)">üóë</button>
        <button class="tool-btn" style="width:auto;padding:0 10px;font-size:14px;background:#ff5b5b" onclick="clearLevel()">Clear</button>
        <div class="tool-sep"></div>
        <button class="tool-btn" style="width:auto;padding:0 10px;font-size:14px;background:#4f86ff" onclick="saveLevel()">Save</button>
        <button class="tool-btn" style="width:auto;padding:0 10px;font-size:14px" onclick="exportLevel()">Export</button>
        <button class="tool-btn" style="width:auto;padding:0 10px;font-size:14px;background:#2e7d32" onclick="toggleEditor()">‚ñ∂ Play</button>
      </div>

      <!-- Touch Controls -->
      <div class="touch-controls" id="touchControls">
        <div class="d-pad">
          <div class="touch-btn" id="btnLeft">‚Üê</div>
          <div class="touch-btn" id="btnRight">‚Üí</div>
        </div>
        <div class="touch-btn" id="btnJump">‚Üë</div>
      </div>
    </div>
  </div>

<script>
const c = document.getElementById('c');
const x = c.getContext('2d');
const W = 1024, H = 576;

// Game state
let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER, VICTORY
let score = 0;
let bestScore = localStorage.getItem('eyeChaseBest') || 0;
document.getElementById('best').textContent = bestScore;
let camera = {x: 0, y: 0};
let twinkle = 0;
let coins = 0;
let coinsCollected = [];
let bestCoins = localStorage.getItem('eyeChaseBestCoins') || 0;
document.getElementById('bestCoins').textContent = bestCoins;
let totalDiamonds = parseInt(localStorage.getItem('eyeChaseDiamonds')) || 0;
let completedLevels = JSON.parse(localStorage.getItem('eyeChaseCompletedLevels') || '[]');
let playerIcon = localStorage.getItem('eyeChasePlayerIcon') || 'default';
let currentLevel = 1;
let menuLevelIndex = 1; // Tracks which level page is open in the menu

// Level Metadata
const LevelInfo = [
  null, // 0-index unused
  { name: "INITIATION", diff: "EASY", color: "#7afcff", desc: "The journey begins." },
  { name: "BOUNCE HOUSE", diff: "EASY", color: "#00ff00", desc: "Boing boing!" },
  { name: "ASCENSION", diff: "MEDIUM", color: "#4f86ff", desc: "Climb higher." },
  { name: "FLOATING", diff: "MEDIUM", color: "#00aaff", desc: "Islands in the sky." },
  { name: "ZIGZAG", diff: "MEDIUM", color: "#ffaa00", desc: "Left, right, jump." },
  { name: "SPIKED", diff: "HARD", color: "#ff5b5b", desc: "Watch your step." },
  { name: "VELOCITY", diff: "HARD", color: "#ffaa00", desc: "Keep moving forward." },
  { name: "ECHO", diff: "HARD", color: "#00ffaa", desc: "Repeat the pattern." },
  { name: "RHYTHM", diff: "HARD", color: "#ff00aa", desc: "Feel the beat." },
  { name: "DESCENT", diff: "HARD", color: "#ff5b5b", desc: "What goes up..." },
  { name: "SPEEDRUN", diff: "HARD", color: "#00ff00", desc: "Gotta go fast." },
  { name: "SKY HIGH", diff: "TOUGH", color: "#d65bff", desc: "Don't look down." },
  { name: "ORBIT", diff: "TOUGH", color: "#aa00ff", desc: "Gravity is a suggestion." },
  { name: "ABYSS", diff: "TOUGH", color: "#440000", desc: "Stare into the void." },
  { name: "ASCENT II", diff: "TOUGH", color: "#4f86ff", desc: "Higher and higher." },
  { name: "MARATHON", diff: "INSANE", color: "#ff00ff", desc: "The ultimate test." },
  { name: "TERMINAL", diff: "INSANE", color: "#ff0000", desc: "End of the line." },
  { name: "GAUNTLET II", diff: "INSANE", color: "#5500ff", desc: "Harder than before." },
  { name: "SPIKEFIELD", diff: "INSANE", color: "#ff0000", desc: "Watch your feet." },
  { name: "PRECISION", diff: "EXTREME", color: "#ffffff", desc: "Pixel perfect." },
  { name: "KAIZO", diff: "EXTREME", color: "#000000", desc: "Unfair." },
  { name: "THE END", diff: "DEMON", color: "#660000", desc: "Final destination." }
];

// --- AUDIO SYSTEM ---
const Audio = {
  ctx: null,
  enabled: true,
  init: function() {
    if(!this.ctx) {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if(this.ctx.state === 'suspended') {
      this.ctx.resume();
    }
  },
  playTone: function(freq, type, duration, vol=0.1) {
    if(!this.enabled || !this.ctx) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
    gain.gain.setValueAtTime(vol, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + duration);
  },
  playJump: function() {
    if(!this.enabled) return;
    this.init();
    // Slide up square wave
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(150, this.ctx.currentTime);
    osc.frequency.linearRampToValueAtTime(300, this.ctx.currentTime + 0.1);
    gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
    gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.1);
  },
  playCoin: function() {
    if(!this.enabled) return;
    this.init();
    // High ping
    this.playTone(1200, 'sine', 0.1, 0.05);
    setTimeout(() => this.playTone(1800, 'sine', 0.2, 0.05), 50);
  },
  playBounce: function() {
    if(!this.enabled) return;
    this.init();
    // Spring sound
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(200, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(600, this.ctx.currentTime + 0.2);
    gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
    gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.2);
  },
  playSuperBounce: function() {
    if(!this.enabled) return;
    this.init();
    // Higher pitched spring sound
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(300, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(900, this.ctx.currentTime + 0.3);
    gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
    gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.3);
  },
  playDie: function() {
    if(!this.enabled) return;
    this.init();
    // Noise/crunch
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(100, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.3);
    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
    gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.3);
  }
};

// Music Sequencer
const Music = {
  bpm: 140,
  nextNoteTime: 0,
  isPlaying: false,
  timerID: null,
  beat: 0,

  // Simple C Minor chase theme
  // Frequencies for C3, Eb3, F3, G3, Bb3, C4...
  notes: {
    'C2': 65.41, 'Eb2': 77.78, 'F2': 87.31, 'G2': 98.00, 'Bb2': 116.54,
    'C3': 130.81, 'Eb3': 155.56, 'F3': 174.61, 'G3': 196.00, 'Bb3': 233.08,
    'C4': 261.63, 'Eb4': 311.13, 'F4': 349.23, 'G4': 392.00, 'Bb4': 466.16,
    'C5': 523.25
  },

  sequence: [
    // Bar 1
    {n: 'C3', d: 0.25}, {n: null, d: 0.25}, {n: 'C3', d: 0.25}, {n: 'Eb3', d: 0.25},
    {n: 'F3', d: 0.25}, {n: 'G3', d: 0.25}, {n: 'C3', d: 0.25}, {n: 'G2', d: 0.25},
    // Bar 2
    {n: 'C3', d: 0.25}, {n: 'C3', d: 0.25}, {n: 'Bb2', d: 0.25}, {n: 'G2', d: 0.25},
    {n: 'F2', d: 0.25}, {n: 'G2', d: 0.25}, {n: 'Bb2', d: 0.25}, {n: 'C3', d: 0.25},
    // Bar 3 (Higher energy)
    {n: 'C4', d: 0.25}, {n: 'G3', d: 0.25}, {n: 'Eb3', d: 0.25}, {n: 'C3', d: 0.25},
    {n: 'G3', d: 0.25}, {n: 'F3', d: 0.25}, {n: 'Eb3', d: 0.25}, {n: 'D3', d: 0.25},
    // Bar 4
    {n: 'C3', d: 0.5}, {n: 'G2', d: 0.5}, {n: 'C2', d: 0.5}, {n: null, d: 0.5}
  ],

  start: function() {
    if(this.isPlaying || !Audio.enabled) return;
    Audio.init();
    this.isPlaying = true;
    this.beat = 0;
    this.nextNoteTime = Audio.ctx.currentTime + 0.1;
    this.scheduler();
  },

  stop: function() {
    this.isPlaying = false;
    clearTimeout(this.timerID);
  },

  scheduler: function() {
    if(!this.isPlaying) return;
    while(this.nextNoteTime < Audio.ctx.currentTime + 0.1) {
      this.playNote(this.beat);
      this.advanceNote();
    }
    this.timerID = setTimeout(() => this.scheduler(), 25);
  },

  playNote: function(beatIndex) {
    const note = this.sequence[beatIndex % this.sequence.length];
    if(note.n) {
      // Bass/Lead synth
      const osc = Audio.ctx.createOscillator();
      const gain = Audio.ctx.createGain();
      osc.type = beatIndex % 8 === 0 ? 'square' : 'triangle'; // Square on downbeats
      osc.frequency.value = this.notes[note.n];

      // Envelope
      gain.gain.setValueAtTime(0.08, this.nextNoteTime);
      gain.gain.exponentialRampToValueAtTime(0.01, this.nextNoteTime + (note.d * 60/this.bpm) * 0.8);

      osc.connect(gain);
      gain.connect(Audio.ctx.destination);
      osc.start(this.nextNoteTime);
      osc.stop(this.nextNoteTime + (note.d * 60/this.bpm));
    }

    // Simple Hi-hat every beat
    if(beatIndex % 2 === 0) {
      const noise = Audio.ctx.createOscillator(); // Using high freq osc as makeshift hi-hat
      const gain = Audio.ctx.createGain();
      noise.type = 'square';
      noise.frequency.value = 8000; // Pseudo-noise
      gain.gain.setValueAtTime(0.01, this.nextNoteTime);
      gain.gain.exponentialRampToValueAtTime(0.001, this.nextNoteTime + 0.05);
      noise.connect(gain);
      gain.connect(Audio.ctx.destination);
      noise.start(this.nextNoteTime);
      noise.stop(this.nextNoteTime + 0.05);
    }
  },

  advanceNote: function() {
    const secondsPerBeat = 60.0 / this.bpm;
    // Assuming all steps are 16th notes (0.25 beat) for simplicity in scheduler
    // But our data structure has 'd' (duration in beats).
    // To keep it simple, we'll advance by the duration of the current note in the sequence
    const currentNote = this.sequence[this.beat % this.sequence.length];
    this.nextNoteTime += currentNote.d * secondsPerBeat;
    this.beat++;
  }
};

// Player (cube that auto-runs)
const player = {
  x: 150, y: 400, w: 30, h: 30,
  vx: 0, vy: 0,
  speed: 4.0, // Fixed slow pace
  accel: 0.5,
  friction: 0.85,
  jumpForce: -14,
  grounded: false,
  rotation: 0,
  jumps: 0,
  maxJumps: 2,
  jumpRequest: false
};

// Eye enemy (Huge size)
const eye = {
  x: -150, y: 200, w: 175, h: 175,
  speed: 1.5 // Reduced speed for "Easy" mode
};

// Level obstacles
let obstacles = [];
let coinObjects = [];
const groundY = H - 80;
let levelLength = 5000;
const stars = Array.from({length: 60}, () => ({
  x: Math.random() * W * 2,
  y: Math.random() * H,
  r: Math.random() * 1.5 + 0.5,
  twinkle: Math.random() * 2
}));
const eyeVeins = Array.from({length: 10}, () => ({
  angle: Math.random() * Math.PI * 2,
  wiggle: Math.random() * Math.PI * 2
}));
const goal = {x: levelLength + 400, y: groundY - 40, r: 55};

// --- LEVEL DATA & EDITOR ---
// Edit these functions to design your levels!

// Helper functions (Global for easy access)
let coinIdCounter = 0;
const addGround = (x, w) => obstacles.push({x, y: groundY, w, h: 80, type: 'ground'});
const addPlat = (x, y, w) => {
  obstacles.push({x, y: groundY - y, w, h: 20, type: 'platform'});
  obstacles.push({x, y: groundY, w, h: 80, type: 'ground'}); // Support pillar
};
const addSpike = (x) => obstacles.push({x, y: groundY - 20, w: 30, h: 20, type: 'spike'});
const addBounce = (x) => {
  obstacles.push({x, y: groundY, w: 200, h: 80, type: 'ground'});
  obstacles.push({x: x + 85, y: groundY - 15, w: 30, h: 15, type: 'bouncePad'});
};
const addSuperBounce = (x) => {
  obstacles.push({x, y: groundY, w: 200, h: 80, type: 'ground'});
  obstacles.push({x: x + 85, y: groundY - 15, w: 30, h: 15, type: 'superBouncePad'});
};
const addCoin = (x, y) => coinObjects.push({x, y: groundY - y, r: 12, id: 'coin_' + (coinIdCounter++)});

const Levels = {
  1: (x) => {
    // Level 1: Intro (Short & Easy) ~2500px
    addGround(x, 200); x += 280; // Gap
    addCoin(x - 40, 75);
    addGround(x, 200); x += 280; // Gap

    addGround(x, 400);
    addSpike(x + 200);
    x += 400;

    addPlat(x, 60, 200);
    addCoin(x + 100, 115);
    x += 250;

    addBounce(x);
    addCoin(x + 100, 225);
    x += 250;

    addGround(x, 500);
    
    // Extension +2000px: Simple platforming fun
    // Staircase up
    addPlat(x, 80, 200); addCoin(x+100, 120); x += 200;
    addPlat(x, 140, 200); x += 200;
    addPlat(x, 200, 200); addCoin(x+100, 240); x += 250;
    
    // Bounce jump
    addBounce(x); x += 250;
    
    // High ground run
    addPlat(x, 200, 600); 
    addCoin(x+150, 240); addCoin(x+300, 240); addCoin(x+450, 240);
    x += 600;
    
    // Drop down to finish
    addGround(x, 200); x += 200;
    addPlat(x, 50, 100); x += 150; // Little hop
    addGround(x, 150); x += 150;
    return x;
  },
  2: (x) => {
      // BOUNCE HOUSE (Old Lvl 11)
      addGround(x, 200); x+=200;
      for(let i=0; i<8; i++) {
          addBounce(x); x+=200;
          addCoin(x, 150); x+=100;
      }
      addGround(x, 200); x+=200;
      return x;
  },
  3: (x) => {
    // Level 2 (Old): Verticality (Medium) ~3500px
    addPlat(x, 50, 150); x += 200;
    addPlat(x, 100, 150); addCoin(x + 75, 130); x += 200;
    addPlat(x, 50, 150); x += 200;

    addGround(x, 300); x += 280; // Gap

    addBounce(x); addCoin(x + 100, 250); x += 200;

    addPlat(x, 120, 200); x += 250;
    addPlat(x, 120, 200); addCoin(x + 100, 150); x += 250;

    // Bridge the gap
    x += 90; addPlat(x, 100, 100); x += 190; 
    
    addPlat(x, 80, 150); x += 200;
    addPlat(x, 140, 150); x += 200;
    addCoin(x + 75, 170);

    addGround(x, 400);
    addSpike(x + 200);
    x += 400;

    // Extension +2000px
    addGround(x, 500); x += 500;
    
    // Zig-Zag Climb
    addPlat(x, 50, 150); x += 200;
    addPlat(x, 120, 150); x += 200;
    addPlat(x, 190, 150); addCoin(x+75, 220); x += 200;
    addPlat(x, 120, 150); x += 200;
    addPlat(x, 50, 150); x += 200;

    addGround(x, 500); addSpike(x + 250); x += 500;
    return x;
  },
  4: (x) => {
      // FLOATING (Old Lvl 14)
      addGround(x, 200); x+=200;
      addPlat(x, 150, 150); x+=200;
      addPlat(x, 250, 150); x+=200;
      addPlat(x, 350, 150); x+=200;
      addPlat(x, 250, 150); x+=200;
      addPlat(x, 150, 150); x+=200;
      addGround(x, 200); x+=200;
      return x;
  },
  5: (x) => {
      // ZIGZAG (Old Lvl 18)
      addGround(x, 200); x+=200;
      for(let i=0; i<4; i++) {
          addPlat(x, 100, 150); x+=150;
          addPlat(x, 250, 150); x+=150;
      }
      addGround(x, 200); x+=200;
      return x;
  },
  6: (x) => {
    // Level 3 (Old): Spikes (Hard) ~4500px
    addGround(x, 250); addSpike(x + 125); x += 250;
    addGround(x, 250); x += 250; // Removed spike
    addGround(x, 250); addSpike(x + 125); addCoin(x + 125, 80); x += 250;

    x += 240; // Reduced gap from 280
    addGround(x, 400); addSpike(x + 200); x += 400; // Wider landing
    x += 240; // Reduced gap

    addBounce(x); x += 200;
    addPlat(x, 100, 200); addCoin(x + 100, 130); x += 250; // Wider platform

    // Double Spike - More space (Nerfed: Removed second spike)
    addGround(x, 600); addSpike(x + 200); x += 600;

    // Tight jumps - Fixed with Bounce Pads
    x += 200;
    addBounce(x); x += 250; // Bounce over first gap

    addGround(x, 200); x += 200;
    addBounce(x); x += 250; // Bounce over second gap

    addGround(x, 200); addCoin(x + 100, 80); x += 250;

    // Extension +2000px
    for(let i=0; i<4; i++) {
      addGround(x, 400); 
      // Safe route above
      addPlat(x + 100, 80, 200); 
      if(i%2===0) addSpike(x+200); // Ground spike
      else addCoin(x+200, 120);
      
      x += 400; 
      if(i === 2) { 
         addSuperBounce(x); x += 200; 
      } else {
         x += 100; 
      }
    }
    return x;
  },
  7: (x) => {
      // VELOCITY (Old Lvl 6)
      addGround(x, 400); x+=400;
      for(let i=0; i<5; i++) {
          addBounce(x); x+=300;
          addPlat(x, 100, 200); addCoin(x+100, 140); x+=200;
          addGround(x, 100); x+=100;
      }
      addGround(x, 500); x+=500;
      return x;
  },
  8: (x) => {
      // ECHO (Old Lvl 7)
      addGround(x, 400); x+=400;
      for(let i=0; i<3; i++) {
         addPlat(x, 100, 150); addSpike(x+50); x+=200;
         addPlat(x, 200, 150); addCoin(x+75, 240); x+=200;
         addGround(x, 150); x+=150;
      }
      addGround(x, 400); x+=400;
      return x;
  },
  9: (x) => {
      // RHYTHM (Old Lvl 15)
      addGround(x, 200); x+=200;
      for(let i=0; i<6; i++) {
          addGround(x, 100); x+=200; // 100 ground, 100 gap
          addCoin(x-50, 50);
      }
      addGround(x, 200); x+=200;
      return x;
  },
  10: (x) => {
      // DESCENT (Old Lvl 17)
      addGround(x, 200); x+=200;
      addSuperBounce(x); x+=300;
      addPlat(x, 400, 200); x+=200;
      addPlat(x, 300, 200); x+=200;
      addPlat(x, 200, 200); x+=200;
      addPlat(x, 100, 200); x+=200;
      addGround(x, 200); x+=200;
      return x;
  },
  11: (x) => {
      // SPEEDRUN (Old Lvl 20)
      addGround(x, 400); x+=400;
      
      // Fast hops with smaller gaps
      addBounce(x); x+=250; // Gap 50 (Easy)
      addBounce(x); x+=250; // Gap 50
      
      // Big Jump with landing platform
      addSuperBounce(x); x+=200;
      addPlat(x, 250, 200); addCoin(x+100, 290); x+=300; // Catch the super jump
      
      addGround(x, 400); x+=400;
      return x;
  },
  12: (x) => {
    // Level 4 (Old): Sky High (Expert) ~5500px
    addGround(x, 150); x += 200;
    addBounce(x); x += 250; // Bounce over first gap

    addGround(x, 150); x += 200;
    addBounce(x); x += 250; // Bounce over second gap

    addGround(x, 150); addCoin(x - 40, 75); x += 290;

    addBounce(x); addCoin(x + 100, 250); x += 250;
    // Fix impossible gap
    x += 160; addPlat(x, 100, 80); x += 160;

    // High platforms
    addPlat(x, 150, 100); x += 250;
    addPlat(x, 180, 100); x += 250;
    // Fix impossible gap
    x += 160; addPlat(x, 100, 80); x += 160;

    addGround(x, 200); addSpike(x + 100); x += 200;
    x += 200;
    addBounce(x); x += 250; // Helper bounce

    addGround(x, 200); addSpike(x + 100); x += 200;

    addBounce(x); x += 250;
    addPlat(x, 200, 150); addCoin(x + 75, 230); x += 250;

    // Extension +2000px
    addGround(x, 200); x += 200;
    addSuperBounce(x); x += 400; // Super jump!
    
    // Broken Islands
    addPlat(x, 200, 150); addCoin(x+75, 240); x += 200;
    x += 100;
    addPlat(x, 200, 150); addCoin(x+75, 240); x += 200;
    x += 100;
    addPlat(x, 200, 150); addCoin(x+75, 240); x += 200;
    
    x += 200;
    addSuperBounce(x); x += 400;
    
    addGround(x, 200); x += 200;
    return x;
  },
  13: (x) => {
      // ORBIT (Old Lvl 8)
      addGround(x, 300); x+=300;
      addSuperBounce(x); x+=400;
      addPlat(x, 300, 200); addCoin(x+100, 340); x+=300;
      addSuperBounce(x); x+=500;
      addPlat(x, 400, 200); addCoin(x+100, 440); x+=300;
      addGround(x, 400); x+=400;
      return x;
  },
  14: (x) => {
      // ABYSS (Old Lvl 9)
      addGround(x, 200); x+=200;
      for(let i=0; i<6; i++) {
          addPlat(x, 50 + i*20, 100); x+=250;
      }
      addGround(x, 400); x+=400;
      return x;
  },
  15: (x) => {
      // ASCENT II (Old Lvl 16)
      addGround(x, 200); x+=200;
      for(let i=0; i<5; i++) {
         addPlat(x, 100 + i*50, 150); x+=150;
      }
      addSuperBounce(x); x+=400;
      addGround(x, 200); x+=200;
      return x;
  },
  16: (x) => {
    // Level 5 (Old): The Marathon (Master) ~7000px

    // Segment 1: Speed
    addPlat(x, 60, 150); x += 200;
    // Fix impossible gap
    x += 140; addPlat(x, 60, 80); x += 140;

    addGround(x, 200); addSpike(x + 100); x += 200;

    // Segment 2: Bounce
    addBounce(x); addCoin(x + 100, 240); x += 200;
    addPlat(x, 100, 150); x += 200;
    // Fix impossible gap
    x += 140; addPlat(x, 80, 80); x += 140; // Reduced gap

    // Segment 3: Precision
    addGround(x, 300); addSpike(x + 150); x += 300;
    x += 200;
    addBounce(x); x += 250; // Added bounce for big gap

    addGround(x, 150); x += 280;
    addGround(x, 150); x += 280;

    // Segment 4: Vertical
    addBounce(x); x += 200;
    addPlat(x, 180, 200); addCoin(x + 100, 210); x += 300;
    addPlat(x, 100, 200); x += 300;

    // Segment 5: Final Sprint
    addGround(x, 800);
    addSpike(x + 200);
    addSpike(x + 400);
    addSpike(x + 600);
    x += 800;

    // Extension +2000px
    addGround(x, 400); x += 400;
    
    // "The Gauntlet"
    addPlat(x, 50, 150); x += 200;
    addBounce(x); x += 250;
    addPlat(x, 150, 300); 
    addCoin(x+100, 190); addCoin(x+200, 190); 
    x += 300;
    
    addSuperBounce(x); x += 400; // High launch
    
    addPlat(x, 250, 100); x += 150;
    addPlat(x, 150, 100); x += 150;
    addPlat(x, 50, 100); x += 150;
    
    addGround(x, 300); x += 300;
    return x;
  },
  17: (x) => {
      // TERMINAL (Old Lvl 10)
      addGround(x, 200); x+=200;
      addSpike(x+100); addPlat(x, 100, 200); x+=250;
      addSuperBounce(x); x+=400;
      addPlat(x, 300, 100); x+=150;
      addPlat(x, 200, 100); x+=150;
      addGround(x, 300); addSpike(x+150); x+=300;
      return x;
  },
  18: (x) => {
      // GAUNTLET II (Old Lvl 13)
      addGround(x, 200); x+=200;
      addPlat(x, 100, 400); addSpike(x+200); x+=450;
      addSuperBounce(x); x+=400;
      addPlat(x, 300, 400); addSpike(x+200); x+=450;
      addGround(x, 200); x+=200;
      return x;
  },
  19: (x) => {
      // SPIKEFIELD (Old Lvl 19)
      addGround(x, 200); x+=200;
      for(let i=0; i<10; i++) {
          addSpike(x+100);
          addPlat(x, 100, 200); 
          x+=250;
      }
      addGround(x, 200); x+=200;
      return x;
  },
  20: (x) => {
      // PRECISION (Old Lvl 12)
      addGround(x, 200); x+=200;
      for(let i=0; i<10; i++) {
          addPlat(x, 100, 80); x+=220;
      }
      addGround(x, 200); x+=200;
      return x;
  },
  21: (x) => {
      // KAIZO (Rebalanced: Precision Platforming)
      addGround(x, 200); x+=200;
      
      // Precise jumps on small platforms
      addPlat(x, 80, 50); x+=140; // Short hop
      addPlat(x, 160, 50); x+=140; // Up
      addPlat(x, 80, 50); x+=140; // Down
      
      // The "Trap" (Safe bounce)
      addBounce(x); x+=200;
      
      // Final landing
      addPlat(x, 150, 100); addCoin(x+50, 200); x+=250;
      addGround(x, 200); x+=200;
      return x;
  },
  22: (x) => {
      // THE END
      addGround(x, 1000); 
      // A victory lap of coins
      for(let i=0; i<10; i++) addCoin(x + 100 + i*80, 50);
      x+=1000;
      return x;
  }
};

// Generate level
function generateLevel() {
  obstacles = [];
  coinObjects = [];
  coinIdCounter = 0;

  if (typeof currentLevel === 'string' && currentLevel.startsWith('custom_')) {
    const index = parseInt(currentLevel.split('_')[1]);
    const list = JSON.parse(localStorage.getItem('eyeChaseLevels') || '[]');
    if(list[index]) {
      obstacles = list[index].data.obstacles;
      coinObjects = list[index].data.coins;
      
      // Load goal or calculate default
      if(list[index].data.goal) {
         goal.x = list[index].data.goal.x;
         goal.y = list[index].data.goal.y;
      } else {
         let maxX = 0;
         obstacles.forEach(o => maxX = Math.max(maxX, o.x + o.w));
         goal.x = maxX + 200;
         goal.y = groundY - 40;
      }
    }
    // Add a safety ground at start if empty (optional, but good for empty levels)
    if(obstacles.length === 0) {
       addGround(0, 800);
       goal.x = 1000;
    }
    return; // Skip standard generation
  }

  let x = 0;

  // 1. Start: Safe running area
  addGround(x, 800);
  x += 800;

  if (Levels[currentLevel]) {
    x = Levels[currentLevel](x);
    
    // Bonus Endurance Section (+2000px)
    addGround(x, 500); x += 500;
    addPlat(x, 100, 300); addCoin(x+150, 140); x += 300;
    addGround(x, 200); x += 200;
    addBounce(x); x += 200;
    addPlat(x, 150, 200); addCoin(x+100, 190); x += 300;
    addGround(x, 500); x += 500;
  }

  // Goal area
  goal.x = x + 200;
  goal.y = groundY - 40;
  addGround(x, 500);
}

// Input
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;

  // Jump Request (for Double Jump)
  if([' ','w','arrowup'].includes(e.key.toLowerCase()) && !e.repeat) {
    player.jumpRequest = true;
  }

  // Restart on Enter
  if(e.key === 'Enter') {
    if(['GAMEOVER', 'VICTORY'].includes(gameState)) {
      startGame();
    } else if(gameState === 'PAUSED') {
      window.resumeGame();
    }
  }

  // Prevent scrolling with arrow keys
  if(['arrowdown','arrowleft','arrowright','arrowup',' '].includes(e.key.toLowerCase())) {
    e.preventDefault();
  }
});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// Dev Tool: Click to log coordinates
// ... (Keep existing implementation or remove if conflicting, let's keep it for now but disable in Editor mode)

// --- EDITOR LOGIC ---
let editorMode = 'SELECT'; // SELECT, GROUND, PLAT, SPIKE, COIN, BOUNCE, SUPER, PORTAL, ERASER
let selectedObj = null;
let hoveredObj = null; // For tooltip
let dragOffset = {x:0, y:0};
let editorCamStart = {x:0, y:0};
let dragStart = {x:0, y:0};
let isDraggingCam = false;
let isDraggingObj = false;

function getSnapSize(type) {
  // Finer grid (10px) for small/precision items
  const small = ['SPIKE','COIN','BOUNCE','SUPER','PORTAL','spike','coin','bouncePad','superBouncePad','goal'];
  if(small.includes(type)) return 10;
  // Coarse grid (20px) for structural items (GROUND, PLAT)
  return 20;
}

function toggleEditor() {
  if(gameState === 'EDITING') {
    gameState = 'PLAYING';
    document.getElementById('editorUI').style.display = 'none';
    document.getElementById('editBtn').classList.remove('active');
    document.getElementById('editBtn').textContent = '‚úé Edit Level';
    // Reset player to safe start or just resume
    Music.start();
  } else {
    gameState = 'EDITING';
    document.getElementById('editorUI').style.display = 'flex';
    document.getElementById('editBtn').classList.add('active');
    document.getElementById('editBtn').textContent = 'Stop Editing';
    document.getElementById('pauseMenu').style.display = 'none';
    Music.stop();
  }
}

function setTool(tool) {
  editorMode = tool;
  document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
  const map = {
    'SELECT': 'toolSelect', 'GROUND': 'toolGround', 'PLAT': 'toolPlat',
    'SPIKE': 'toolSpike', 'COIN': 'toolCoin', 'BOUNCE': 'toolBounce', 'SUPER': 'toolSuper', 
    'PORTAL': 'toolPortal', 'ERASER': 'toolEraser'
  };
  if(map[tool]) document.getElementById(map[tool]).classList.add('active');
  selectedObj = null;
}

// Bind toolbar buttons
document.getElementById('toolSelect').onclick = () => setTool('SELECT');
document.getElementById('toolGround').onclick = () => setTool('GROUND');
document.getElementById('toolPlat').onclick = () => setTool('PLAT');
document.getElementById('toolSpike').onclick = () => setTool('SPIKE');
document.getElementById('toolCoin').onclick = () => setTool('COIN');
document.getElementById('toolBounce').onclick = () => setTool('BOUNCE');
document.getElementById('toolSuper').onclick = () => setTool('SUPER');
document.getElementById('toolPortal').onclick = () => setTool('PORTAL');
document.getElementById('toolEraser').onclick = () => setTool('ERASER');

window.clearLevel = function() {
  if(confirm('Clear entire level?')) {
    obstacles = [];
    coinObjects = [];
    // Add starting ground to prevent infinite fall
    addGround(0, 800);
  }
};

window.saveLevel = function() {
  const name = prompt('Name your level:', 'My Level');
  if(name) {
    const list = JSON.parse(localStorage.getItem('eyeChaseLevels') || '[]');
    const data = { 
        obstacles: obstacles, 
        coins: coinObjects,
        goal: {x: goal.x, y: goal.y} 
    };
    list.push({ name, data, date: Date.now() });
    localStorage.setItem('eyeChaseLevels', JSON.stringify(list));
    alert('Level Saved!');
  }
};

window.startNewLevelEditor = function() {
  // Reset level data
  obstacles = [];
  coinObjects = [];
  addGround(0, 800);
  
  // Reset player & camera
  player.x = 150; player.y = 466;
  camera = {x: 0, y: 0};
  
  // Default goal
  goal.x = 1000; goal.y = groundY - 40;
  
  // Switch to Editor state
  gameState = 'EDITING';
  
  // Update UI
  document.getElementById('editorUI').style.display = 'flex';
  document.getElementById('editBtn').classList.add('active');
  document.getElementById('editBtn').textContent = 'Stop Editing';
  document.getElementById('pauseMenu').style.display = 'none';
  document.getElementById('msg').style.display = 'none';
  
  // Ensure HUD is visible (since we might come from MENU)
  document.querySelector('.hud').style.opacity = '1';
  
  Music.stop();
};

window.exportLevel = function() {
  const data = {
    obstacles: obstacles.map(o => ({...o})),
    coins: coinObjects.map(c => ({...c}))
  };
  console.log(JSON.stringify(data));
  alert('Level data exported to Console (F12)');
};

// Editor Input Handling
c.addEventListener('mousedown', (e) => {
  if(gameState !== 'EDITING') return;
  
  const rect = c.getBoundingClientRect();
  const scaleX = c.width / rect.width;
  const scaleY = c.height / rect.height;
  const mx = (e.clientX - rect.left) * scaleX + camera.x;
  const my = (e.clientY - rect.top) * scaleY + camera.y;
  
  // Always allow pan with Middle Mouse or Shift+Click
  // AND allow standard drag-pan if NO tool is selected (or just empty space in SELECT mode?)
  // Let's just make left-click on empty space in SELECT mode pan the camera
  let hitObject = false;
  if(editorMode === 'SELECT' || editorMode === 'ERASER') {
    // Check if we clicked an object
    // (Reuse logic below to detect hit)
    // Actually let's just run selection logic first
  }

  if(e.button === 1 || (e.button === 0 && e.shiftKey)) {
    isDraggingCam = true;
    dragStart = {x: e.clientX, y: e.clientY};
    editorCamStart = {x: camera.x, y: camera.y};
    return;
  }

  if(editorMode === 'SELECT' || editorMode === 'ERASER') {
    // Try select coin first (smaller target)
    selectedObj = null;
    let target = null;
    
    for(let c of coinObjects) {
      if(Math.hypot(c.x - mx, c.y - my) < c.r + 5) {
        target = c;
        target._type = 'coin'; // Marker
        break;
      }
    }
    if(!target) {
      // Try select obstacle
      for(let i = obstacles.length - 1; i >= 0; i--) {
        let o = obstacles[i];
        if(mx >= o.x && mx <= o.x + o.w && my >= o.y && my <= o.y + o.h) {
          target = o;
          target._type = 'obstacle';
          break;
        }
      }
    }
    
    if(target) {
       if(editorMode === 'ERASER') {
          // Delete immediately
          if(target._type === 'coin') {
             const idx = coinObjects.indexOf(target);
             if(idx > -1) coinObjects.splice(idx, 1);
          } else {
             const idx = obstacles.indexOf(target);
             if(idx > -1) obstacles.splice(idx, 1);
          }
          selectedObj = null;
          hitObject = true; // prevent pan
       } else {
          // Select Mode
          selectedObj = target;
          dragOffset = {x: mx - target.x, y: my - target.y};
          hitObject = true;
          isDraggingObj = true;
       }
    }
    
    // If we didn't hit anything in SELECT mode, start panning
    if(!hitObject) {
        isDraggingCam = true;
        dragStart = {x: e.clientX, y: e.clientY};
        editorCamStart = {x: camera.x, y: camera.y};
    }
  } else {
    // Place object
    // Dynamic snap based on tool
    const snap = getSnapSize(editorMode);
    const gx = Math.floor(mx / snap) * snap;
    const gy = Math.floor(my / snap) * snap;
    
    if(editorMode === 'GROUND') addGround(gx, 200);
    else if(editorMode === 'PLAT') addPlat(0, groundY - gy, 100); // y param is height from ground
    else if(editorMode === 'SPIKE') obstacles.push({x: gx, y: gy, w: 30, h: 20, type: 'spike'});
    else if(editorMode === 'COIN') coinObjects.push({x: gx, y: gy, r: 12, id: 'c'+Date.now()});
    else if(editorMode === 'BOUNCE') {
        obstacles.push({x: gx, y: gy, w: 30, h: 15, type: 'bouncePad'});
    }
    else if(editorMode === 'SUPER') {
        obstacles.push({x: gx, y: gy, w: 30, h: 15, type: 'superBouncePad'});
    }
    else if(editorMode === 'PORTAL') {
        // Update global goal position
        goal.x = gx + 55; // Center circle
        goal.y = gy + 55; // Adjust for radius
        // We don't push to obstacles/coins array, it's a global singular object
    }
    
    // Modify the last added object to position exactly at click if needed, 
    // but add* helpers use ground-relative logic. 
    // Let's fix generic placement for non-helper types:
    if(['SPIKE','BOUNCE','SUPER'].includes(editorMode)) {
       // already pushed with gy
    } else if(editorMode === 'PORTAL') {
       // Handled above
    } else if(editorMode === 'GROUND') {
       // addGround uses fixed Y, let's override
       obstacles[obstacles.length-1].y = gy;
       obstacles[obstacles.length-1].x = gx;
    } else if(editorMode === 'PLAT') {
       // addPlat pushes 2 objects (plat + pillar). Let's just push a platform rect
       obstacles.pop(); obstacles.pop(); // remove helper result
       obstacles.push({x: gx, y: gy, w: 100, h: 20, type: 'platform'});
    }
  }
});

window.addEventListener('mousemove', (e) => {
  if(gameState !== 'EDITING') return;

  // Update hovered object for tooltip
  const rect = c.getBoundingClientRect();
  const scaleX = c.width / rect.width;
  const scaleY = c.height / rect.height;
  const mx = (e.clientX - rect.left) * scaleX + camera.x;
  const my = (e.clientY - rect.top) * scaleY + camera.y;
  
  hoveredObj = null;
  // Check coins
  for(let c of coinObjects) {
    if(Math.hypot(c.x - mx, c.y - my) < c.r + 5) {
      hoveredObj = c; hoveredObj._type = 'coin'; break;
    }
  }
  // Check obstacles
  if(!hoveredObj) {
    for(let i = obstacles.length - 1; i >= 0; i--) {
      let o = obstacles[i];
      if(mx >= o.x && mx <= o.x + o.w && my >= o.y && my <= o.y + o.h) {
        hoveredObj = o; hoveredObj._type = 'obstacle'; break;
      }
    }
  }
  
  // Check Portal (Goal)
  if(!hoveredObj) {
     if(Math.hypot(goal.x - mx, goal.y - my) < goal.r) {
        hoveredObj = goal; hoveredObj._type = 'goal';
     }
  }

  if(isDraggingCam) {
    const dx = (e.clientX - dragStart.x) * (c.width / c.clientWidth);
    const dy = (e.clientY - dragStart.y) * (c.height / c.clientHeight);
    camera.x = editorCamStart.x - dx;
    camera.y = editorCamStart.y - dy;
    return;
  }

  if(selectedObj && isDraggingObj) {
    const rect = c.getBoundingClientRect();
    const scaleX = c.width / rect.width;
    const scaleY = c.height / rect.height;
    const mx = (e.clientX - rect.left) * scaleX + camera.x;
    const my = (e.clientY - rect.top) * scaleY + camera.y;

    // Free movement with Alt key, otherwise snap to grid
    if(e.altKey) {
      selectedObj.x = mx - dragOffset.x;
      selectedObj.y = my - dragOffset.y;
    } else {
      const type = selectedObj.type || selectedObj._type;
      const snap = getSnapSize(type);
      selectedObj.x = Math.floor((mx - dragOffset.x) / snap) * snap;
      selectedObj.y = Math.floor((my - dragOffset.y) / snap) * snap;
    }
  }
});

window.addEventListener('mouseup', () => {
  // Don't clear selection immediately if we just clicked (so we can delete)
  isDraggingCam = false;
  isDraggingObj = false;
});

window.addEventListener('keydown', (e) => {
  if(gameState === 'EDITING') {
    // Delete selected object
    if((e.key === 'Delete' || e.key === 'Backspace') && selectedObj) {
      if(selectedObj._type === 'coin') {
        const idx = coinObjects.indexOf(selectedObj);
        if(idx > -1) coinObjects.splice(idx, 1);
      } else {
        const idx = obstacles.indexOf(selectedObj);
        if(idx > -1) obstacles.splice(idx, 1);
      }
      selectedObj = null;
    }
    
    // Move camera with arrows
    if(e.key === 'ArrowLeft') camera.x -= 20;
    if(e.key === 'ArrowRight') camera.x += 20;
    if(e.key === 'ArrowUp') camera.y -= 20;
    if(e.key === 'ArrowDown') camera.y += 20;
  }
});

// Collision detection
function collision(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x &&
         a.y < b.y + b.h && a.y + a.h > b.y;
}

function spikeCollision(p, s) {
  // Precise Triangle vs AABB collision using Separating Axis Theorem (SAT)
  // We only need to test the 2 slope normals, as AABB (x/y axes) are already checked

  // Spike vertices
  const sA = {x: s.x, y: s.y + s.h}; // Bottom Left
  const sB = {x: s.x + s.w/2, y: s.y}; // Top Tip
  const sC = {x: s.x + s.w, y: s.y + s.h}; // Bottom Right

  // Player vertices
  const p1 = {x: p.x, y: p.y};
  const p2 = {x: p.x + p.w, y: p.y};
  const p3 = {x: p.x + p.w, y: p.y + p.h};
  const p4 = {x: p.x, y: p.y + p.h};
  const pVerts = [p1, p2, p3, p4];

  // Axes to test: Normals of the two slopes
  // Left slope normal: (h, w/2)
  const axis1 = {x: s.h, y: s.w/2};
  // Right slope normal: (-h, w/2)
  const axis2 = {x: -s.h, y: s.w/2};

  const axes = [axis1, axis2];

  for(let axis of axes) {
    // Project Spike
    let minS = Infinity, maxS = -Infinity;
    [sA, sB, sC].forEach(v => {
      const proj = v.x * axis.x + v.y * axis.y;
      minS = Math.min(minS, proj);
      maxS = Math.max(maxS, proj);
    });

    // Project Player
    let minP = Infinity, maxP = -Infinity;
    pVerts.forEach(v => {
      const proj = v.x * axis.x + v.y * axis.y;
      minP = Math.min(minP, proj);
      maxP = Math.max(maxP, proj);
    });

    // Check for gap (Separating Axis Found)
    if (maxS < minP || maxP < minS) return false;
  }

  return true;
}

// Update player
function updatePlayer() {
  // Manual movement with physics
  let move = 0;
  if(keys['d'] || keys['arrowright']) move = 1;
  if(keys['a'] || keys['arrowleft']) move = -1;

  // Apply acceleration
  if (move !== 0) {
    player.vx += move * player.accel;
    // Cap speed
    if (player.vx > player.speed) player.vx = player.speed;
    if (player.vx < -player.speed) player.vx = -player.speed;
  } else {
    // Apply friction when no input
    player.vx *= player.friction;
    // Snap to 0 if very slow
    if(Math.abs(player.vx) < 0.1) player.vx = 0;
  }

  player.x += player.vx;

  // Jump Logic (Double Jump enabled)
  if(player.jumpRequest) {
    if (player.grounded) {
      player.vy = player.jumpForce;
      player.grounded = false;
      player.jumps = 1;
      Audio.playJump();
    } else if (player.jumps < player.maxJumps) {
      player.vy = player.jumpForce * 0.85; // Second jump
      player.jumps++;
      player.rotation = 0; // Reset rotation for feel
      Audio.playJump();
    }
    player.jumpRequest = false;
  }

  // Ensure player doesn't go backwards too far (optional, but keeps level flow)
  if(player.x < 0) {
    player.x = 0;
    player.vx = 0;
  }

  // Gravity
  player.vy += 0.8;
  player.y += player.vy;

  // Rotation when in air
  if(!player.grounded) {
    player.rotation += 0.15;
  } else {
    player.rotation = Math.round(player.rotation / (Math.PI/2)) * (Math.PI/2);
  }

  // Check collisions
  player.grounded = false;
  for(let o of obstacles) {
    if(collision(player, o)) {
      if(o.type === 'spike') {
        // Precise spike collision check
        if(spikeCollision(player, o)) {
          gameOver();
          return;
        }
        // If spikeCollision is false, we are in the empty corner of the hitbox - safe!
      }
      else if(o.type === 'bouncePad') {
        // Launch player upward
        player.vy = -22;
        player.grounded = false;
        player.jumps = 1; // Treat bounce as first jump (allows 1 more)
        Audio.playBounce();
      }
      else if(o.type === 'superBouncePad') {
        // Super launch
        player.vy = -35;
        player.grounded = false;
        player.jumps = 1;
        Audio.playSuperBounce();
      }
      if(o.type === 'ground' || o.type === 'platform') {
        if(player.vy > 0 && player.y + player.h - player.vy < o.y + 5) {
          player.y = o.y - player.h;
          player.vy = 0;
          player.grounded = true;
          player.jumps = 0; // Reset jumps
        }
      }
    }
  }

  // Fall off screen = death
  if(player.y > H + 50) gameOver();

  // Check coin collection
  for(let coin of coinObjects) {
    if(coinsCollected.includes(coin.id)) continue;

    const dist = Math.sqrt(
      Math.pow(player.x + player.w/2 - coin.x, 2) +
      Math.pow(player.y + player.h/2 - coin.y, 2)
    );

    // Increased collection radius (magnet effect)
    // Was: player.w/2 + coin.r (~15 + 12 = 27)
    // Now: player.w/2 + coin.r + 50 (~77) - Super easy!
    if(dist < player.w/2 + coin.r + 50) {
      coinsCollected.push(coin.id);
      coins++;
      document.getElementById('coins').textContent = coins;
      Audio.playCoin();
    }
  }

  // Check goal reach
  const goalBox = {
    x: goal.x - goal.r,
    y: goal.y - goal.r,
    w: goal.r * 2,
    h: goal.r * 2
  };
  if(collision(player, goalBox)) {
    reachGoal();
    return;
  }

  // Update camera to follow player
  camera.x = player.x - 200;
  
  // Vertical camera scrolling (Only go up if player is high up)
  // Default ground level view is y=0 (since we draw ground at H-80)
  // If player goes above a threshold (e.g. top 30% of screen), move camera up
  const targetCamY = Math.min(0, player.y - H * 0.3);
  
  // Smooth lerp
  camera.y += (targetCamY - camera.y) * 0.1;
}

// Update eye
function updateEye() {
  const desiredX = Math.max(player.x - eye.w * 0.9, camera.x - eye.w * 0.6);
  const desiredY = player.y - eye.h / 2 + 10;

  // Constant speed movement (no acceleration)
  if (eye.x < desiredX) {
    eye.x += eye.speed;
    if (eye.x > desiredX) eye.x = desiredX;
  }

  // Smooth Y movement is fine
  eye.y += (desiredY - eye.y) * 0.1;

  // Maintain a safe trailing distance so the player is never caught
  const minTrailing = eye.w * 0.75;
  if(player.x - (eye.x + eye.w) < minTrailing) {
    eye.x = player.x - eye.w - minTrailing;
  }

  // Keep eye within viewable bounds
  if(eye.x < camera.x - eye.w * 0.6) eye.x = camera.x - eye.w * 0.6;
  if(eye.x + eye.w > camera.x + W - 60) eye.x = camera.x + W - 60 - eye.w;
}

// My Levels UI (Hidden by default)
// Using existing HTML structure? No, need to inject it or draw it.
// Let's inject a modal div for easier management than canvas drawing.
if(!document.getElementById('levelList')) {
  const div = document.createElement('div');
  div.id = 'levelList';
  div.className = 'overlay';
  div.style.cssText = 'display:none;background:#0d1a2a;border:2px solid #4f86ff;padding:20px;border-radius:12px;top:50%;left:50%;transform:translate(-50%,-50%);width:400px;max-height:400px;overflow-y:auto;z-index:200';
  div.innerHTML = `
    <h2 style="margin-top:0">My Levels</h2>
    <div id="levelListContent" style="display:flex;flex-direction:column;gap:10px"></div>
    <button onclick="closeLevelList()" style="margin-top:20px;background:#ff5b5b;width:100%">Close</button>
  `;
  document.querySelector('.wrap').appendChild(div);
}

// Icons UI
if(!document.getElementById('iconList')) {
  const div = document.createElement('div');
  div.id = 'iconList';
  div.className = 'overlay';
  div.style.cssText = 'display:none;background:#0d1a2a;border:2px solid #ff00ff;padding:20px;border-radius:12px;top:50%;left:50%;transform:translate(-50%,-50%);width:320px;z-index:200';
  div.innerHTML = `
    <h2 style="margin-top:0;color:#ff00ff">Select Icon</h2>
    <div id="iconGrid" style="display:grid;grid-template-columns:repeat(4, 1fr);gap:10px"></div>
    <button onclick="document.getElementById('iconList').style.display='none'" style="margin-top:20px;background:#ff5b5b;width:100%">Close</button>
  `;
  document.querySelector('.wrap').appendChild(div);
}

window.openIconsMenu = function() {
  const grid = document.getElementById('iconGrid');
  grid.innerHTML = '';
  
  const icons = ['default', 'üòÉ', 'üòé', 'üòà', 'üëª', 'üëΩ', 'ü§ñ', 'üê±', 'üê∂', 'üêµ', 'ü¶ä', 'üê∏', 'üêº', 'ü¶Ñ', 'üê≤', 'üü¶', 'üü•', 'üü©', 'üü®'];
  
  icons.forEach(icon => {
    const btn = document.createElement('button');
    btn.style.cssText = 'font-size:24px;padding:10px;background:' + (playerIcon === icon ? '#4f86ff' : '#1b2a44');
    btn.innerHTML = icon === 'default' ? 'Cube' : icon;
    btn.onclick = () => {
      playerIcon = icon;
      localStorage.setItem('eyeChasePlayerIcon', icon);
      document.getElementById('iconList').style.display = 'none';
    };
    grid.appendChild(btn);
  });
  
  document.getElementById('iconList').style.display = 'block';
};

window.openLevelList = function() {
  const list = JSON.parse(localStorage.getItem('eyeChaseLevels') || '[]');
  const content = document.getElementById('levelListContent');
  content.innerHTML = '';
  
  if(list.length === 0) {
    content.innerHTML = '<div style="color:#888">No saved levels yet.</div>';
  } else {
    list.forEach((lvl, i) => {
      const row = document.createElement('div');
      row.style.cssText = 'display:flex;gap:10px;background:#1b2a44;padding:10px;border-radius:8px;align-items:center';
      row.innerHTML = `
        <div style="flex:1;font-weight:bold">${lvl.name || 'Level ' + (i+1)}</div>
        <button onclick="playCustomLevel(${i})" style="background:#2e7d32;padding:5px 10px;font-size:14px">Play</button>
        <button onclick="editCustomLevel(${i})" style="background:#4f86ff;padding:5px 10px;font-size:14px">Edit</button>
        <button onclick="deleteCustomLevel(${i})" style="background:#ff5b5b;padding:5px 10px;font-size:14px">‚úñ</button>
      `;
      content.appendChild(row);
    });
  }
  document.getElementById('levelList').style.display = 'block';
};

window.closeLevelList = function() {
  document.getElementById('levelList').style.display = 'none';
};

window.playCustomLevel = function(index) {
  const list = JSON.parse(localStorage.getItem('eyeChaseLevels') || '[]');
  if(list[index]) {
    currentLevel = 'custom_' + index;
    closeLevelList();
    startGame();
  }
};

window.editCustomLevel = function(index) {
  playCustomLevel(index); // Load it
  setTimeout(() => toggleEditor(), 100); // Switch to edit mode
};

window.deleteCustomLevel = function(index) {
  if(confirm('Delete this level?')) {
    const list = JSON.parse(localStorage.getItem('eyeChaseLevels') || '[]');
    list.splice(index, 1);
    localStorage.setItem('eyeChaseLevels', JSON.stringify(list));
    openLevelList(); // Refresh
  }
};

window.saveLevel = function() {
  const name = prompt('Name your level:', 'My Level');
  if(name) {
    const list = JSON.parse(localStorage.getItem('eyeChaseLevels') || '[]');
    const data = { obstacles, coins: coinObjects };
    list.push({ name, data, date: Date.now() });
    localStorage.setItem('eyeChaseLevels', JSON.stringify(list));
    alert('Level Saved!');
  }
};

// Draw Menu
function drawMenu() {
  // Clear with gradient background
  const gradient = x.createLinearGradient(0, 0, 0, H);
  gradient.addColorStop(0, '#071228');
  gradient.addColorStop(1, '#020817');
  x.fillStyle = gradient;
  x.fillRect(0, 0, W, H);

  // Star field
  twinkle += 0.01;
  x.save();
  x.globalAlpha = 0.7;
  for(const star of stars) {
    const brightness = 0.6 + Math.sin(twinkle + star.twinkle) * 0.3;
    x.fillStyle = `rgba(180, 220, 255, ${brightness})`;
    x.beginPath();
    x.arc(star.x - W, star.y, star.r, 0, Math.PI * 2); // Simple star position for menu
    x.fill();
  }
  x.restore();

  // Title
  x.save();
  x.textAlign = 'center';

  // "EYE"
  x.font = 'bold 120px Inter, system-ui';
  x.fillStyle = '#ff2a2a';
  x.shadowColor = '#000';
  x.shadowBlur = 0;
  x.lineWidth = 8;
  x.strokeStyle = '#000';
  x.strokeText('EYE', W/2, H/2 - 60);
  x.fillText('EYE', W/2, H/2 - 60);

  // "CHASE"
  x.fillStyle = '#7afcff';
  x.strokeText('CHASE', W/2, H/2 + 50);
  x.fillText('CHASE', W/2, H/2 + 50);
  
  // Total Diamonds
  x.font = 'bold 24px Inter, system-ui';
  x.fillStyle = '#fff';
  x.lineWidth = 4;
  x.strokeText('üíé ' + totalDiamonds, W/2, H/2 + 90);
  x.fillText('üíé ' + totalDiamonds, W/2, H/2 + 90);

  // Play Button
  const btnW = 200;
  const btnH = 60;
  const btnX = W/2 - btnW/2;
  const btnY = H/2 + 120;

  x.shadowBlur = 20;
  x.shadowColor = 'rgba(79, 134, 255, 0.6)';
  x.fillStyle = '#4f86ff';
  // Draw rounded rect
  x.beginPath();
  x.roundRect(btnX, btnY, btnW, btnH, 30);
  x.fill();

  // Button Text
  x.shadowBlur = 0;
  x.font = 'bold 28px Inter, system-ui';
  x.fillStyle = '#fff';
  x.textBaseline = 'middle';
  x.lineWidth = 3;
  x.strokeStyle = 'rgba(0,0,0,0.5)';
  x.strokeText('PLAY', W/2, btnY + btnH/2);
  x.fillText('PLAY', W/2, btnY + btnH/2);

  // Create Button (Left)
  const createBtnX = W/2 - 280;
  const sideBtnW = 160;
  x.shadowBlur = 20;
  x.shadowColor = 'rgba(122, 252, 255, 0.4)';
  x.fillStyle = '#1b2a44';
  x.strokeStyle = '#7afcff';
  x.lineWidth = 2;
  x.beginPath();
  x.roundRect(createBtnX, btnY, sideBtnW, btnH, 30);
  x.fill();
  x.stroke();

  x.fillStyle = '#7afcff';
  x.font = 'bold 20px Inter, system-ui';
  x.lineWidth = 3;
  x.strokeStyle = 'rgba(0,0,0,0.8)';
  x.strokeText('CREATE', createBtnX + sideBtnW/2, btnY + btnH/2);
  x.fillText('CREATE', createBtnX + sideBtnW/2, btnY + btnH/2);

  // My Levels Button (Right)
  const myBtnX = W/2 + 120;
  x.shadowBlur = 20;
  x.shadowColor = 'rgba(255, 0, 255, 0.4)';
  x.fillStyle = '#2a1b44';
  x.strokeStyle = '#ff00ff';
  x.lineWidth = 2;
  x.beginPath();
  x.roundRect(myBtnX, btnY, sideBtnW, btnH, 30);
  x.fill();
  x.stroke();

  x.fillStyle = '#ff00ff';
  x.font = 'bold 20px Inter, system-ui';
  x.lineWidth = 3;
  x.strokeStyle = 'rgba(0,0,0,0.8)';
  x.strokeText('MY LEVELS', myBtnX + sideBtnW/2, btnY + btnH/2);
  x.fillText('MY LEVELS', myBtnX + sideBtnW/2, btnY + btnH/2);

  // Icons Button (Top Right)
  const iconBtnX = W - 140;
  const iconBtnY = 30;
  x.shadowBlur = 10;
  x.shadowColor = 'rgba(255, 255, 255, 0.3)';
  x.fillStyle = '#1b2a44';
  x.strokeStyle = '#fff';
  x.lineWidth = 2;
  x.beginPath();
  x.roundRect(iconBtnX, iconBtnY, 110, 50, 15);
  x.fill();
  x.stroke();
  
  x.shadowBlur = 0;
  x.fillStyle = '#fff';
  x.font = 'bold 18px Inter, system-ui';
  x.lineWidth = 3;
  x.strokeStyle = 'rgba(0,0,0,0.8)';
  x.strokeText('üôÇ SKINS', iconBtnX + 55, iconBtnY + 25);
  x.fillText('üôÇ SKINS', iconBtnX + 55, iconBtnY + 25);

  // Credits/Controls
  x.font = '16px Inter, system-ui';
  x.fillStyle = '#fff'; // Brighter
  x.lineWidth = 3;
  x.strokeStyle = '#000';
  x.strokeText('Controls: Arrows / WASD / Touch', W/2, H - 40);
  x.fillText('Controls: Arrows / WASD / Touch', W/2, H - 40);

  x.restore();
}

// Draw Level Select
function drawLevelSelect() {
  // Clear
  const gradient = x.createLinearGradient(0, 0, 0, H);
  gradient.addColorStop(0, '#071228');
  gradient.addColorStop(1, '#020817');
  x.fillStyle = gradient;
  x.fillRect(0, 0, W, H);

  const info = LevelInfo[menuLevelIndex];
  const isLocked = false; // Logic for locking could go here

  // 1. Level Name (Title)
  x.save();
  x.textAlign = 'center';
  x.shadowBlur = 20;
  x.shadowColor = info.color;
  x.fillStyle = '#fff';
  x.font = 'bold 60px Inter, system-ui';
  x.lineWidth = 4;
  x.strokeStyle = '#000';
  x.strokeText(info.name, W/2, H/2 - 140);
  x.fillText(info.name, W/2, H/2 - 140);

  // 2. Difficulty Face / Label
  x.font = 'bold 30px Inter, system-ui';
  x.fillStyle = info.color;
  x.lineWidth = 3;
  x.strokeText(info.diff, W/2, H/2 - 90);
  x.fillText(info.diff, W/2, H/2 - 90);
  
  // 3. Description
  x.font = 'italic 20px Inter, system-ui';
  x.fillStyle = '#eee'; // Brighter
  x.shadowBlur = 0;
  x.lineWidth = 3;
  x.strokeText(info.desc, W/2, H/2 - 50);
  x.fillText(info.desc, W/2, H/2 - 50);

  // 4. Stats (Diamonds)
  const levelId = menuLevelIndex.toString();
  const completed = completedLevels.includes(levelId);
  const reward = menuLevelIndex * 10;
  
  x.font = '24px Inter, system-ui';
  x.lineWidth = 3;
  x.strokeStyle = '#000';
  if(completed) {
      x.fillStyle = '#4f86ff'; // Blue for completed
      x.strokeText(`Completed! (Reward: ${reward} üíé)`, W/2, H/2 - 10);
      x.fillText(`Completed! (Reward: ${reward} üíé)`, W/2, H/2 - 10);
  } else {
      x.fillStyle = '#7afcff';
      x.strokeText(`Reward: ${reward} üíé`, W/2, H/2 - 10);
      x.fillText(`Reward: ${reward} üíé`, W/2, H/2 - 10);
  }

  // 5. Central Play Button
  const btnW = 200;
  const btnH = 80;
  const btnX = W/2 - btnW/2;
  const btnY = H/2 + 40;

  x.shadowBlur = 20;
  x.shadowColor = info.color;
  x.fillStyle = '#1b2a44';
  x.beginPath();
  x.roundRect(btnX, btnY, btnW, btnH, 40);
  x.fill();
  x.strokeStyle = info.color;
  x.lineWidth = 3;
  x.stroke();

  x.shadowBlur = 0;
  x.fillStyle = '#fff';
  x.font = 'bold 36px Inter, system-ui';
  x.textBaseline = 'middle';
  x.lineWidth = 3;
  x.strokeStyle = 'rgba(0,0,0,0.5)';
  x.strokeText('PLAY', W/2, btnY + btnH/2);
  x.fillText('PLAY', W/2, btnY + btnH/2);

  // 6. Navigation Arrows (<  >)
  x.font = 'bold 60px Inter, system-ui';
  x.fillStyle = '#fff';
  x.lineWidth = 4;
  x.strokeStyle = '#000';
  
  // Left Arrow
  if(menuLevelIndex > 1) {
    x.strokeText('<', W/2 - 200, H/2 + 80);
    x.fillText('<', W/2 - 200, H/2 + 80);
  }
  
  // Right Arrow
  if(menuLevelIndex < 22) {
    x.strokeText('>', W/2 + 200, H/2 + 80);
    x.fillText('>', W/2 + 200, H/2 + 80);
  }

  // 7. Page Indicator (Dots)
  // Adjusted for many levels - maybe show just a progress bar or number if > 10?
  // Let's switch to "Page X / 22" text for cleaner UI
  x.font = '20px Inter, system-ui';
  x.fillStyle = '#fff'; // Brighter
  x.lineWidth = 3;
  x.strokeText(`${menuLevelIndex} / 22`, W/2, H - 80);
  x.fillText(`${menuLevelIndex} / 22`, W/2, H - 80);
  
  /* Dots removed for scalability
  const dotSize = 10;
  const dotGap = 20;
  */

  x.restore();

  // Back Button (Red Cross)
  const backX = 30;
  const backY = 30;
  const backSize = 40;

  x.save();
  x.fillStyle = '#ff5b5b';
  x.shadowColor = 'rgba(255, 91, 91, 0.5)';
  x.shadowBlur = 10;
  x.beginPath();
  x.arc(backX + backSize/2, backY + backSize/2, backSize/2, 0, Math.PI * 2);
  x.fill();

  x.strokeStyle = '#fff';
  x.lineWidth = 4;
  x.lineCap = 'round';
  x.shadowBlur = 0;
  x.beginPath();
  // X shape
  const pad = 10;
  x.moveTo(backX + pad, backY + pad);
  x.lineTo(backX + backSize - pad, backY + backSize - pad);
  x.moveTo(backX + backSize - pad, backY + pad);
  x.lineTo(backX + pad, backY + backSize - pad);
  x.stroke();
  x.restore();
}

// Render
function draw() {
  // Clear with gradient background
  const gradient = x.createLinearGradient(0, 0, 0, H);
  gradient.addColorStop(0, '#071228');
  gradient.addColorStop(1, '#020817');
  x.fillStyle = gradient;
  x.fillRect(0, 0, W, H);

  // Star field with subtle parallax
  twinkle += 0.01;
  x.save();
  x.globalAlpha = 0.7;
  for(const star of stars) {
    const parallaxX = ((star.x - camera.x * 0.2) % (W * 2) + W * 2) % (W * 2);
    const parallaxY = ((star.y - camera.y * 0.1) % H + H) % H; // Slight vertical parallax
    const brightness = 0.6 + Math.sin(twinkle + star.twinkle) * 0.3;
    x.fillStyle = `rgba(180, 220, 255, ${brightness})`;
    x.beginPath();
    x.arc(parallaxX - W, parallaxY, star.r, 0, Math.PI * 2);
    x.fill();
  }
  x.restore();

  x.save();
  x.translate(-camera.x, -camera.y);

  // Draw obstacles
  for(let o of obstacles) {
    if(o.x + o.w < camera.x - 100 || o.x > camera.x + W + 100) continue;

    if(o.type === 'ground') {
      const groundGradient = x.createLinearGradient(o.x, o.y, o.x, o.y + o.h);
      groundGradient.addColorStop(0, '#0e2f4f');
      groundGradient.addColorStop(1, '#0a233a');
      x.fillStyle = groundGradient;
      x.fillRect(o.x, o.y, o.w, o.h);
      
      // Ground texture (tech grid)
      x.fillStyle = 'rgba(122, 252, 255, 0.05)';
      for(let i=0; i<o.w; i+=40) {
         x.fillRect(o.x + i, o.y, 2, o.h);
         x.fillRect(o.x + i + 10, o.y + 10, 4, 4); // Dot
      }
      
      x.fillStyle = 'rgba(122, 252, 255, 0.08)';
      x.fillRect(o.x, o.y, o.w, 6);
    } else if(o.type === 'platform') {
      const platGradient = x.createLinearGradient(o.x, o.y, o.x, o.y + o.h);
      platGradient.addColorStop(0, '#81b8ff');
      platGradient.addColorStop(1, '#4f86ff');
      x.fillStyle = platGradient;
      x.fillRect(o.x, o.y, o.w, o.h);
      x.strokeStyle = 'rgba(255,255,255,0.25)';
      x.strokeRect(o.x, o.y, o.w, o.h);
      
      // Rivets
      x.fillStyle = 'rgba(0,0,0,0.3)';
      x.beginPath();
      x.arc(o.x + 5, o.y + 5, 2, 0, Math.PI*2);
      x.arc(o.x + o.w - 5, o.y + 5, 2, 0, Math.PI*2);
      x.arc(o.x + 5, o.y + o.h - 5, 2, 0, Math.PI*2);
      x.arc(o.x + o.w - 5, o.y + o.h - 5, 2, 0, Math.PI*2);
      x.fill();
    } else if(o.type === 'spike') {
      x.fillStyle = '#ff5b5b';
      x.shadowColor = 'rgba(255,91,91,0.4)';
      x.shadowBlur = 12;
      x.beginPath();
      x.moveTo(o.x, o.y + o.h);
      x.lineTo(o.x + o.w/2, o.y);
      x.lineTo(o.x + o.w, o.y + o.h);
      x.closePath();
      x.fill();
      x.shadowBlur = 0;
    } else if(o.type === 'bouncePad') {
      // Draw bounce pad with spring effect
      const bounceGradient = x.createLinearGradient(o.x, o.y, o.x, o.y + o.h);
      bounceGradient.addColorStop(0, '#7cff7a');
      bounceGradient.addColorStop(1, '#2e7d32');
      x.fillStyle = bounceGradient;
      x.fillRect(o.x, o.y, o.w, o.h);
      x.strokeStyle = 'rgba(255,255,255,0.4)';
      x.lineWidth = 2;
      x.strokeRect(o.x, o.y, o.w, o.h);

      // Draw horizontal spring lines
      x.strokeStyle = 'rgba(0,0,0,0.4)';
      x.lineWidth = 3;
      for(let i = 1; i < 4; i++) {
        const lineY = o.y + (o.h / 4) * i;
        x.beginPath();
        x.moveTo(o.x + 4, lineY);
        x.lineTo(o.x + o.w - 4, lineY);
        x.stroke();
      }
      // Arrow Up
      x.fillStyle = 'rgba(255,255,255,0.7)';
      x.beginPath();
      x.moveTo(o.x + o.w/2, o.y + 3);
      x.lineTo(o.x + o.w/2 - 5, o.y + 8);
      x.lineTo(o.x + o.w/2 + 5, o.y + 8);
      x.fill();
    } else if(o.type === 'superBouncePad') {
      // Draw SUPER bounce pad (purple/pink)
      const bounceGradient = x.createLinearGradient(o.x, o.y, o.x, o.y + o.h);
      bounceGradient.addColorStop(0, '#ff00ff');
      bounceGradient.addColorStop(1, '#800080');
      x.fillStyle = bounceGradient;
      x.fillRect(o.x, o.y, o.w, o.h);
      x.strokeStyle = 'rgba(255,255,255,0.6)';
      x.lineWidth = 2;
      x.strokeRect(o.x, o.y, o.w, o.h);

      // Draw horizontal spring lines
      x.strokeStyle = 'rgba(255,255,255,0.6)';
      x.lineWidth = 3;
      for(let i = 1; i < 4; i++) {
        const lineY = o.y + (o.h / 4) * i;
        x.beginPath();
        x.moveTo(o.x + 4, lineY);
        x.lineTo(o.x + o.w - 4, lineY);
        x.stroke();
      }
      // Double Arrow Up
      x.fillStyle = 'rgba(255,255,255,0.8)';
      x.beginPath();
      x.moveTo(o.x + o.w/2, o.y + 2);
      x.lineTo(o.x + o.w/2 - 5, o.y + 6);
      x.lineTo(o.x + o.w/2 + 5, o.y + 6);
      x.fill();
      x.beginPath();
      x.moveTo(o.x + o.w/2, o.y + 7);
      x.lineTo(o.x + o.w/2 - 5, o.y + 11);
      x.lineTo(o.x + o.w/2 + 5, o.y + 11);
      x.fill();
    }
  }

  // Draw coins
  const coinTime = performance.now() * 0.003;
  for(let coin of coinObjects) {
    if(coinsCollected.includes(coin.id)) continue;
    if(coin.x + coin.r < camera.x - 50 || coin.x - coin.r > camera.x + W + 50) continue;

    x.save();
    x.translate(coin.x, coin.y);

    // Floating animation
    const float = Math.sin(coinTime + coin.x * 0.01) * 3;
    x.translate(0, float);

    // Rotation
    x.rotate(coinTime * 2);

    // Glow
    x.shadowColor = 'rgba(255, 215, 0, 0.6)';
    x.shadowBlur = 15;

    // Outer ring
    const coinGradient = x.createRadialGradient(0, 0, 0, 0, 0, coin.r);
    coinGradient.addColorStop(0, '#ffd700');
    coinGradient.addColorStop(0.7, '#ffed4e');
    coinGradient.addColorStop(1, '#ffa500');
    x.fillStyle = coinGradient;
    x.beginPath();
    x.arc(0, 0, coin.r, 0, Math.PI * 2);
    x.fill();

    // Inner circle
    x.fillStyle = '#ffed4e';
    x.beginPath();
    x.arc(0, 0, coin.r * 0.6, 0, Math.PI * 2);
    x.fill();

    // Dollar sign or star pattern
    x.fillStyle = '#ffa500';
    x.font = 'bold ' + (coin.r * 1.2) + 'px Arial';
    x.textAlign = 'center';
    x.textBaseline = 'middle';
    x.fillText('$', 0, 0);

    x.shadowBlur = 0;
    x.restore();
  }

  // Draw goal portal
  if(goal.x < camera.x + W + 200) {
    const time = performance.now() * 0.001;
    x.save();
    x.translate(goal.x, goal.y);
    const portalPulse = 1 + Math.sin(time * 3) * 0.08;
    x.scale(portalPulse, portalPulse);

    const ringGradient = x.createRadialGradient(0, 0, goal.r * 0.3, 0, 0, goal.r);
    ringGradient.addColorStop(0, 'rgba(122, 252, 255, 0.9)');
    ringGradient.addColorStop(1, 'rgba(80, 140, 255, 0.2)');
    x.fillStyle = ringGradient;
    x.beginPath();
    x.arc(0, 0, goal.r, 0, Math.PI * 2);
    x.fill();

    x.strokeStyle = 'rgba(122, 252, 255, 0.9)';
    x.lineWidth = 6;
    x.beginPath();
    x.arc(0, 0, goal.r * 0.78, 0, Math.PI * 2);
    x.stroke();

    x.rotate(time * 2);
    x.fillStyle = 'rgba(255,255,255,0.7)';
    for(let i = 0; i < 4; i++) {
      x.save();
      x.rotate((Math.PI / 2) * i);
      x.beginPath();
      x.moveTo(0, -goal.r * 0.4);
      x.lineTo(goal.r * 0.12, 0);
      x.lineTo(0, goal.r * 0.4);
      x.lineTo(-goal.r * 0.12, 0);
      x.closePath();
      x.fill();
      x.restore();
    }

    x.rotate(time * -3);
    x.fillStyle = 'rgba(122, 252, 255, 0.85)';
    x.beginPath();
    x.arc(0, 0, goal.r * 0.35, 0, Math.PI * 2);
    x.fill();

    x.restore();
  }

  // Draw player (rotating cube)
  x.save();
  x.translate(player.x + player.w/2, player.y + player.h/2);
  x.rotate(player.rotation);
  
  // 1. Outer Border (Black Outline)
  x.fillStyle = '#000';
  x.fillRect(-player.w/2 - 2, -player.h/2 - 2, player.w + 4, player.h + 4);

  // 2. Main Body Gradient (Primary Color)
  const playerGradient = x.createLinearGradient(-player.w/2, -player.h/2, player.w/2, player.h/2);
  playerGradient.addColorStop(0, '#7afcff'); // Cyan
  playerGradient.addColorStop(1, '#008cff'); // Blue
  x.fillStyle = playerGradient;
  x.fillRect(-player.w/2, -player.h/2, player.w, player.h);

  // 3. Inner Frame/Border (Inset)
  x.strokeStyle = 'rgba(0,0,0,0.2)';
  x.lineWidth = 3;
  x.strokeRect(-player.w/2 + 3, -player.h/2 + 3, player.w - 6, player.h - 6);

  // 4. Gloss/Shine (Top Half Reflection)
  const gloss = x.createLinearGradient(0, -player.h/2, 0, 0);
  gloss.addColorStop(0, 'rgba(255,255,255,0.6)');
  gloss.addColorStop(1, 'rgba(255,255,255,0.0)');
  x.fillStyle = gloss;
  x.fillRect(-player.w/2, -player.h/2, player.w, player.h/2);

  // 5. Face / Icon
  if(playerIcon !== 'default' && playerIcon) {
    x.font = '22px Arial'; // Slightly larger
    x.textAlign = 'center';
    x.textBaseline = 'middle';
    
    // Icon Outline (Black)
    x.lineWidth = 3;
    x.strokeStyle = '#000';
    x.strokeText(playerIcon, 0, 2);
    
    // Icon Fill (White)
    x.fillStyle = '#fff';
    x.fillText(playerIcon, 0, 2); 
  } else {
    // Default Face (GD Style Square)
    x.fillStyle = 'rgba(0,0,0,0.4)';
    x.fillRect(-7, -7, 14, 14); // Outer dark square
    x.fillStyle = '#afffff';
    x.fillRect(-4, -4, 8, 8);   // Inner light square
  }
  x.restore();

  // Draw eye enemy
  const auraPulse = 1 + Math.sin(performance.now() * 0.002) * 0.12;
  const auraRadius = eye.w * 0.65 * auraPulse;
  const auraGradient = x.createRadialGradient(
    eye.x + eye.w/2, eye.y + eye.h/2, eye.w * 0.3,
    eye.x + eye.w/2, eye.y + eye.h/2, auraRadius
  );
  auraGradient.addColorStop(0, 'rgba(255, 122, 122, 0.6)');
  auraGradient.addColorStop(1, 'rgba(255, 60, 60, 0)');
  x.fillStyle = auraGradient;
  x.beginPath();
  x.arc(eye.x + eye.w/2, eye.y + eye.h/2, auraRadius, 0, Math.PI * 2);
  x.fill();

  const eyeGradient = x.createRadialGradient(
    eye.x + eye.w/2, eye.y + eye.h/2, eye.w * 0.2,
    eye.x + eye.w/2, eye.y + eye.h/2, eye.w/2
  );
  eyeGradient.addColorStop(0, '#ff7676');
  eyeGradient.addColorStop(1, '#ff2a2a');
  x.fillStyle = eyeGradient;
  x.beginPath();
  x.arc(eye.x + eye.w/2, eye.y + eye.h/2, eye.w/2, 0, Math.PI * 2);
  x.fill();

  // Eye white
  x.fillStyle = '#fff';
  x.beginPath();
  x.arc(eye.x + eye.w/2, eye.y + eye.h/2, eye.w/3, 0, Math.PI * 2);
  x.fill();

  // Eye veins
  const veinTime = performance.now() * 0.001;
  x.save();
  x.translate(eye.x + eye.w/2, eye.y + eye.h/2);
  x.strokeStyle = 'rgba(255, 100, 100, 0.5)';
  x.lineWidth = 2;
  for(const vein of eyeVeins) {
    const dynamicAngle = vein.angle + Math.sin(veinTime * 2 + vein.wiggle) * 0.2;
    const innerRadius = eye.w * 0.1;
    const outerRadius = eye.w * 0.45;
    const controlRadius = (innerRadius + outerRadius) / 2;
    const jitter = Math.sin(veinTime * 3 + vein.wiggle) * eye.w * 0.05;
    x.beginPath();
    x.moveTo(Math.cos(dynamicAngle) * innerRadius, Math.sin(dynamicAngle) * innerRadius);
    x.quadraticCurveTo(
      Math.cos(dynamicAngle) * controlRadius + jitter,
      Math.sin(dynamicAngle) * controlRadius + jitter,
      Math.cos(dynamicAngle) * outerRadius,
      Math.sin(dynamicAngle) * outerRadius
    );
    x.stroke();
  }
  x.restore();

  // Pupil pointing at player
  const angle = Math.atan2(player.y - (eye.y + eye.h/2), player.x - (eye.x + eye.w/2));
  const pupilOffset = eye.w/5;
  const pupilSize = eye.w/8;
  x.fillStyle = '#000';
  x.beginPath();
  x.arc(
    eye.x + eye.w/2 + Math.cos(angle) * pupilOffset,
    eye.y + eye.h/2 + Math.sin(angle) * pupilOffset,
    pupilSize, 0, Math.PI * 2
  );
  x.fill();

  x.restore();

  // UI
  x.fillStyle = '#dff6ff';
  x.font = '24px Inter, system-ui';
  x.fillText('Distance: ' + Math.floor(player.x / 10), 20, 40);

  // Progress bar
  const progress = Math.min(1, player.x / goal.x);
  x.fillStyle = 'rgba(122, 252, 255, 0.15)';
  x.fillRect(20, 55, 200, 10);
  const barGradient = x.createLinearGradient(20, 55, 220, 55);
  barGradient.addColorStop(0, '#7afcff');
  barGradient.addColorStop(1, '#81b5ff');
  x.fillStyle = barGradient;
  x.fillRect(20, 55, 200 * progress, 10);
}

// Game loop
function gameLoop() {
  if(gameState === 'MENU') {
    drawMenu();
    document.querySelector('.hud').style.opacity = '0';
    document.getElementById('touchControls').style.display = 'none';
    document.getElementById('pauseMenu').style.display = 'none';
  } else if(gameState === 'LEVEL_SELECT') {
    drawLevelSelect();
    document.querySelector('.hud').style.opacity = '0';
    document.getElementById('touchControls').style.display = 'none';
    document.getElementById('pauseMenu').style.display = 'none';
  } else if(gameState === 'PLAYING') {
    document.querySelector('.hud').style.opacity = '1';
    if(window.ontouchstart === null) { // crude check if touch was enabled
       // actually touchControls are managed by touch events, let's leave them alone or show them if needed
    }

    updatePlayer();
    updateEye();
    draw();

    score = player.x;
  } else if(gameState === 'EDITING') {
    // Draw level without updates
    draw();
    
    // Draw Editor Overlay
    const ctx = x;
    ctx.save();
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
    ctx.lineWidth = 1;
    
    // Grid
    const gridSize = 20; // Changed to 20px
    const offsetX = -camera.x % gridSize;
    const offsetY = -camera.y % gridSize;
    
    ctx.beginPath();
    for(let i = offsetX; i < W; i += gridSize) {
      ctx.moveTo(i, 0); ctx.lineTo(i, H);
    }
    for(let i = offsetY; i < H; i += gridSize) {
      ctx.moveTo(0, i); ctx.lineTo(W, i);
    }
    ctx.stroke();
    
    // Highlight Selection
    if(selectedObj) {
      ctx.strokeStyle = '#ff0';
      ctx.lineWidth = 2;
      if(selectedObj._type === 'coin') {
        ctx.beginPath();
        ctx.arc(selectedObj.x, selectedObj.y, selectedObj.r + 5, 0, Math.PI*2);
        ctx.stroke();
      } else {
        ctx.strokeRect(selectedObj.x - 2, selectedObj.y - 2, selectedObj.w + 4, selectedObj.h + 4);
      }
    }
    
    ctx.restore();
    ctx.fillRect(10, H - 40, 400, 30);
    ctx.fillStyle = '#fff';
    ctx.font = '16px monospace';
    
    let statusText = 'Mode: ' + editorMode + ' | Drag Space to Pan | Del to Remove';
    if(hoveredObj) {
       const type = hoveredObj.type || 'coin';
       statusText = 'Hovering: ' + type.toUpperCase() + ' | ' + statusText;
    }
    ctx.fillText(statusText, 20, H - 20);
    
    ctx.restore();
    
  } else if(gameState === 'PAUSED') {
    draw();
  } else {
    // Game Over / Victory state
    // Continue drawing for background effects if desired, or just freeze
    draw();
  }

  requestAnimationFrame(gameLoop);
}

// Game over
function gameOver() {
  gameState = 'GAMEOVER';
  Audio.playDie();
  Music.stop();
  if(score > bestScore) {
    bestScore = Math.floor(score);
    localStorage.setItem('eyeChaseBest', bestScore);
    document.getElementById('best').textContent = bestScore;
  }
  if(coins > bestCoins) {
    bestCoins = coins;
    localStorage.setItem('eyeChaseBestCoins', bestCoins);
    document.getElementById('bestCoins').textContent = bestCoins;
  }
  document.getElementById('msg').innerHTML = `
    <div style="margin-bottom:20px;font-size:32px;font-weight:bold">You Died</div>
    <div style="margin-bottom:20px;font-size:18px">Press Enter to restart</div>
    <div style="display:flex;gap:20px;justify-content:center">
      <button onclick="startGame()" style="background:#4f86ff;font-size:20px;padding:12px 24px">Try Again</button>
      <button onclick="window.exitLevel()" style="background:#ff5b5b;font-size:20px;padding:12px 24px">Exit Level</button>
    </div>
  `;
  document.getElementById('msg').style.display = 'block';
}

function reachGoal() {
  if(gameState === 'VICTORY') return;
  gameState = 'VICTORY';
  Music.stop();
  // Victory fanfare (arpeggio)
  if(Audio.enabled) {
    Audio.playTone(523.25, 'square', 0.1); // C5
    setTimeout(() => Audio.playTone(659.25, 'square', 0.1), 100); // E5
    setTimeout(() => Audio.playTone(783.99, 'square', 0.1), 200); // G5
    setTimeout(() => Audio.playTone(1046.5, 'square', 0.4), 300); // C6
  }
  if(score > bestScore) {
    bestScore = Math.floor(score);
    localStorage.setItem('eyeChaseBest', bestScore);
    document.getElementById('best').textContent = bestScore;
  }
  if(coins > bestCoins) {
    bestCoins = coins;
    localStorage.setItem('eyeChaseBestCoins', bestCoins);
    document.getElementById('bestCoins').textContent = bestCoins;
  }

  // Award Diamonds
  let reward = 0;
  let alreadyCompleted = false;
  
  // Check if already completed
  const levelId = currentLevel.toString(); // works for '1' or 'custom_0'
  if(completedLevels.includes(levelId)) {
     alreadyCompleted = true;
  } else {
     completedLevels.push(levelId);
     localStorage.setItem('eyeChaseCompletedLevels', JSON.stringify(completedLevels));
  }

  if(!alreadyCompleted) {
      if(typeof currentLevel === 'number') {
        // 10, 20, ... up to 100 max
        reward = Math.min(currentLevel * 10, 100);
      } else {
        // Custom levels get 5
        reward = 5;
      }
      
      totalDiamonds += reward;
      localStorage.setItem('eyeChaseDiamonds', totalDiamonds);
      document.getElementById('diamondDisplay').textContent = totalDiamonds;
  }

  const rewardMsg = alreadyCompleted 
      ? `<div style="margin-bottom:20px;font-size:18px;color:#aaa">No rewards (Already Completed)</div>`
      : `<div style="margin-bottom:20px;font-size:24px;color:#7afcff">üíé +${reward} Diamonds</div>`;

  document.getElementById('msg').innerHTML = `
    <div style="margin-bottom:10px;font-size:32px;font-weight:bold">Level Complete!</div>
    ${rewardMsg}
    <div style="display:flex;gap:20px;justify-content:center">
      <button onclick="window.nextLevel()" style="background:#4f86ff;font-size:20px;padding:12px 24px">Next Level</button>
      <button onclick="window.toMenu()" style="background:#1b2a44;font-size:20px;padding:12px 24px">Menu</button>
    </div>
  `;
  document.getElementById('msg').style.display = 'block';
}

// Start game
function startGame() {
  player.x = 150;
  player.y = 466; // Start on ground
  player.vx = 0;
  player.vy = 0;
  player.rotation = 0;
  player.grounded = false;
  eye.x = -150;
  eye.y = 200;
  eye.w = 175;
  eye.h = 175;
  eye.speed = 2.0; // Fixed slow speed
  camera = {x: 0, y: 0};
  score = 0;
  coins = 0;
  coinsCollected = [];
  document.getElementById('coins').textContent = coins;
  document.getElementById('diamondDisplay').textContent = totalDiamonds;
  generateLevel();

  gameState = 'PLAYING';
  document.getElementById('msg').style.display = 'none';
  document.getElementById('pauseMenu').style.display = 'none';
  Music.start();
}

// Button handlers
document.getElementById('pauseBtn').onclick = function() {
  if(gameState === 'PLAYING') {
    gameState = 'PAUSED';
    document.getElementById('pauseMenu').style.display = 'block';
    document.getElementById('touchControls').style.display = 'none';
    Music.stop();
  } else if(gameState === 'PAUSED') {
    window.resumeGame();
  }
};

document.getElementById('restartBtn').onclick = function() {
  if(['PLAYING', 'PAUSED', 'GAMEOVER', 'VICTORY'].includes(gameState)) {
    startGame();
  }
};

document.getElementById('muteBtn').onclick = function() {
  Audio.enabled = !Audio.enabled;
  if(Audio.enabled) {
    Audio.init();
    this.textContent = 'üîä Music On';
    this.classList.remove('active');
    if(gameState === 'PLAYING') Music.start();
  } else {
    this.textContent = 'üîá Music Off';
    this.classList.add('active');
    Music.stop();
    if(Audio.ctx) Audio.ctx.suspend();
  }
};
c.ondblclick = null;

// Touch Controls
const touchControls = document.getElementById('touchControls');

// Show touch controls if touch device is detected
window.addEventListener('touchstart', function onFirstTouch() {
  // Only show controls if we are playing, otherwise menu should handle it (or we can show dpad in menu?)
  // Let's leave them hidden in menu as per gameLoop logic
  // But we need to enable them so gameLoop CAN show them
  document.getElementById('touchControls').classList.add('touch-enabled'); // Just a marker if needed
  window.removeEventListener('touchstart', onFirstTouch, false);
}, false);

const btnLeft = document.getElementById('btnLeft');
const btnRight = document.getElementById('btnRight');
const btnJump = document.getElementById('btnJump');

const handleTouch = (btn, key, isDown) => {
  btn.addEventListener(isDown ? 'touchstart' : 'touchend', (e) => {
    e.preventDefault(); // Prevent default zoom/scroll behavior
    keys[key] = isDown;

    // Special handling for restart on jump touch
    if(key === ' ' && isDown) {
      if(gameState === 'GAMEOVER') {
        startGame();
      }
    }
  }, {passive: false});
};

// Bind touch events
handleTouch(btnLeft, 'arrowleft', true);
handleTouch(btnLeft, 'arrowleft', false);
handleTouch(btnRight, 'arrowright', true);
handleTouch(btnRight, 'arrowright', false);
handleTouch(btnJump, ' ', true);
handleTouch(btnJump, ' ', false);

// Handle tap/click on canvas for Menu start
const checkMenuClick = (e) => {
   const rect = c.getBoundingClientRect();
   // Scale mouse coordinates to canvas resolution
   const scaleX = c.width / rect.width;
   const scaleY = c.height / rect.height;

   const clientX = e.touches ? e.touches[0].clientX : e.clientX;
   const clientY = e.touches ? e.touches[0].clientY : e.clientY;

   const x = (clientX - rect.left) * scaleX;
   const y = (clientY - rect.top) * scaleY;

   if(gameState === 'MENU') {
      // Check Play Button (W/2 - 100, H/2 + 120, 200, 60)
      const btnX = W/2 - 100;
      const btnY = H/2 + 120;
      const btnW = 200;
      const btnH = 60;

      if(x >= btnX && x <= btnX + btnW && y >= btnY && y <= btnY + btnH) {
         e.preventDefault();
         gameState = 'LEVEL_SELECT';
      }
      
      // Check Create Button (W/2 - 280, btnY, 160, 60)
      const createBtnX = W/2 - 280;
      if(x >= createBtnX && x <= createBtnX + 160 && y >= btnY && y <= btnY + btnH) {
         e.preventDefault();
         startNewLevelEditor();
      }
      
      // Check My Levels Button (W/2 + 120, btnY, 160, 60)
      const myBtnX = W/2 + 120;
      if(x >= myBtnX && x <= myBtnX + 160 && y >= btnY && y <= btnY + btnH) {
         e.preventDefault();
         openLevelList();
      }
      
      // Check Icons Button (W - 140, 30, 110, 50)
      const iconBtnX = W - 140;
      if(x >= iconBtnX && x <= iconBtnX + 110 && y >= 30 && y <= 30 + 50) {
         e.preventDefault();
         openIconsMenu();
      }
   } else if(gameState === 'LEVEL_SELECT') {
      // Navigation Arrows
      // Left Arrow: W/2 - 200 +/- 40
      if(menuLevelIndex > 1 && x >= W/2 - 240 && x <= W/2 - 160 && y >= H/2 + 40 && y <= H/2 + 120) {
          menuLevelIndex--;
          return;
      }
      // Right Arrow: W/2 + 200 +/- 40
      if(menuLevelIndex < 22 && x >= W/2 + 160 && x <= W/2 + 240 && y >= H/2 + 40 && y <= H/2 + 120) {
          menuLevelIndex++;
          return;
      }
      
      // Central Play Button
      const btnW = 200;
      const btnH = 80;
      const btnX = W/2 - btnW/2;
      const btnY = H/2 + 40;
      
      if(x >= btnX && x <= btnX + btnW && y >= btnY && y <= btnY + btnH) {
         e.preventDefault();
         currentLevel = menuLevelIndex;
         startGame();
         return;
      }

      // Check Back Button (30, 30, 40, 40)
      const backX = 30;
      const backY = 30;
      const backSize = 40;

      if(x >= backX && x <= backX + backSize && y >= backY && y <= backY + backSize) {
         e.preventDefault();
         gameState = 'MENU';
      }
   } else if(gameState === 'GAMEOVER') {
      e.preventDefault();
      startGame(); // Restart
   } else if(gameState === 'VICTORY') {
      // Do nothing on canvas click, rely on HTML buttons
   }
};

c.addEventListener('touchstart', checkMenuClick);
c.addEventListener('mousedown', checkMenuClick); // Also support mouse click

// Global navigation functions
window.nextLevel = function() {
  if (currentLevel < 22) {
    currentLevel++;
  } else {
    currentLevel = 1; // Loop back to 1
  }
  startGame();
};
window.toMenu = function() {
  gameState = 'LEVEL_SELECT';
  document.getElementById('msg').style.display = 'none';
};
window.resumeGame = function() {
  gameState = 'PLAYING';
  document.getElementById('pauseMenu').style.display = 'none';
  if(window.ontouchstart !== undefined || navigator.maxTouchPoints > 0) {
     document.getElementById('touchControls').style.display = 'flex';
  }
  Music.start();
};
window.exitLevel = function() {
  gameState = 'LEVEL_SELECT';
  document.getElementById('pauseMenu').style.display = 'none';
  document.getElementById('msg').style.display = 'none'; // Hide game over/victory msg
  document.getElementById('touchControls').style.display = 'none';
  Music.stop();
};

// Initial setup
gameLoop();
</script>
